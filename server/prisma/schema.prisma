generator client {
   provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url = env("DATABASE_URL")
}

model Account {
  accountId      String  @id @default(uuid())
  email   String
  phoneNumber Int
  user User?
  enabled Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  passwordHistories PasswordHistories[]
  @@unique([accountId, email, phoneNumber])
}

model User {
  userId   String  @id @default(uuid())
  // username String
  // password String
  account   Account @relation(fields: [accountId, email, phoneNumber], references: [accountId, email, phoneNumber])
  accountId String
  name String
  email String
  phoneNumber Int
  deActivatedOn DateTime
  createdOn DateTime @default(now())
  updatedOn DateTime
  role Role
  student Student?
  instructor Instructor?
  moderator Moderator?
  administrator Administrators?
  rToken RefreshTokens?
  oToken OtpToken?
  eToken EmailToken?
  

  @@unique([accountId, email, phoneNumber])
}

model Student{
  studentId String @id @default(uuid())
  user   User @relation(fields: [userId], references: [userId])
  userId String
  transaction Transaction[]
  purchasedCourse PurchasedCourse[]
  @@unique([userId])
}

model Instructor{
  instructorId String @id @default(uuid())
  user User @relation(fields: [userId], references: [userId])
  userId String
  course Course[]
  @@unique([userId])
}

model Moderator{
  moderatorId String @id @default(uuid())
  user User @relation(fields: [userId], references: [userId])
  userId String
  @@unique([userId])
}

model Administrators{
  administratorId String @id @default(uuid())
  user User @relation(fields: [userId], references: [userId])
  userId String
  @@unique([userId])
}

model Course{
  courseId String @id @default(uuid()) 
  courseName String
  duration DateTime @db.Time
  price Int
  description String
  language Language
  status Status
  approvalStatus Status
  createdOn DateTime @default(now())
  updatedOn DateTime @updatedAt
  instructor Instructor @relation(fields: [instructorId], references: [instructorId])
  instructorId String
  courseMaterial CourseMaterial[]
  topic Topics[]
  purchasedCourse PurchasedCourse[]
  // missing topics, approved by
}

model CourseMaterial {
  courseMaterialId String @id @default(uuid())
  url String
  course Course @relation(fields: [courseId], references: [courseId])
  courseId String
}

model Transaction {
  transactionId String @id @default(uuid())
  status Status
  createdOn DateTime @default(now())
  student Student @relation(fields: [studentId], references: [studentId])
  studentId String
  purchasedCourse PurchasedCourse[]
}

model PurchasedCourse {
  courseMaterialId String @id @default(uuid())
  transactionId String
  courseId String
  studentId String
  student Student @relation(fields: [studentId], references: [studentId])
  course Course @relation(fields: [courseId], references: [courseId])
  transaction Transaction @relation(fields: [transactionId], references: [transactionId])
  @@unique([transactionId, courseId, studentId])
}

model Topics {
  topicId String @id
  topicName String
  description String
  course Course @relation(fields: [courseId], references: [courseId])
  courseId String
}

model PasswordHistories {
  id           String  @id @default(uuid())
  passwordHash String
  enabled      Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Accounts   Account @relation(fields: [accountsId], references: [accountId])
  accountsId String
  @@unique([accountsId, passwordHash])
}

model RefreshTokens {
  rTokenId String @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiredAt DateTime
  user User @relation(fields: [userId], references: [userId])
  userId String   @unique 
}

model OtpToken {
  oTokenId String @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiredAt DateTime
  user User @relation(fields: [userId], references: [userId])
  userId String   @unique 
}

model EmailToken {
  eTokenId String @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiredAt DateTime
  user User @relation(fields: [userId], references: [userId])
  userId String   @unique 
}

enum Role {
  User
  Student
  Instructor
  Moderator
  Employees
  Administrators
}

enum Language {
  Chinese
  English
  French
  Indian
  Japanese
  Korean
  Malay
}

// enum Status {
//   Pending   // Waiting to be approved
//   Approved // Approved but not avaiable to public
//   Declined  // Course is declined
//   Ongoing   // Approved and content is avaialble to subscribers
//   Stopped   //Approved but content not available to anyone
// }

enum Status {
  InProgress
  Pending
  Completed
  Approved
  Ongoing
  Started
}

// model Products {
//   id          String @id @default(uuid())
//   name        String @unique
//   description String
//   quantity    Int    @default(1)
//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
//   createdBy   AdminAccounts @relation(fields: [createdById], references: [id])
//   createdById String
// }

// model ClientAccounts {
//   id            String @id @default(uuid())
//   firstName     String
//   lastName      String
//   contactNumber Int
//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
//   account   Accounts @relation(fields: [accountId], references: [id])
//   accountId String   @unique
// }

// model AdminAccounts {
//   id        String   @id @default(uuid())
//   account   Accounts @relation(fields: [accountId], references: [id])
//   accountId String   @unique
//   firstName String
//   lastName  String
//   createdAt DateTime   @default(now())
//   updatedAt DateTime   @updatedAt
//   Products  Products[]
// }